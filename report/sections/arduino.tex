\section{Arduino Implementation}
All the sensor nodes are boiled down to the Arduino. We have 2 actual sensor simulators: the \textbf{built-in Arduino's led} and the \textbf{servo}. The \textbf{temperature} and \textbf{humidity} data are randomly generated by the Arduino's hardware. Listing \ref{code:arduino-program-part1} provides the first part of the source code for this Arduino program, in which we declare some useful symbolic constants and global variables.

\begin{lstlisting}[language=C++, caption= Arduino Program (part 1), escapeinside={(*}{*)}, label=code:arduino-program-part1]
#include <Servo.h>

const int BUFFER_SIZE = 100; (*\label{code:arduino-program-part1:buff-size}*)
char buff[BUFFER_SIZE];      (*\label{code:arduino-program-part1:buff-array}*)

Servo servo;                 (*\label{code:arduino-program-part1:servo}*)
const int servoPIN = 12;
const int servoMin = 100;
const int servoMax = 180;    (*\label{code:arduino-program-part1:servo-max}*)

const int publishDelay = 20000;   // publish every 20s
unsigned long myTime  = millis();
\end{lstlisting}
We're gonna need a buffer to store the incoming messages sent by the Gateway, so we reserve an array of characters whose length defined by the constant \texttt{BUFFER\_SIZE} (line \ref{code:arduino-program-part1:buff-size} and line \ref{code:arduino-program-part1:buff-array}). Line \ref{code:arduino-program-part1:servo} through \ref{code:arduino-program-part1:servo-max} of the listing are the global variables involved in the control of our \texttt{servo}. We will publish random temperature and humidity value every \texttt{publishDealy} milliseconds, and use the variable \texttt{myTime} to control the delay without actually freezing the big while loop (since the big while loop is also responsible for monitoring the incoming messages).
\begin{lstlisting}[language=C++, caption= Arduino Program (part 2), escapeinside={(*}{*)}, label=code:arduino-part2]
void setup() {
  // setup built in led
  pinMode(LED_BUILTIN, OUTPUT);

  // setup servo
  servo.attach(servoPIN);
  servo.write(servoMin); (*\label{code:arduino-part2:servoMin}*)
  
  // set baud rate
  Serial.begin(9600);

  // seed the PRNG
  randomSeed(analogRead(0));
}
\end{lstlisting}
Now we are ready to define the \texttt{setup()} function, as shown in Listing \ref{code:arduino-part2}. The \texttt{setup()} function is straightforward. We use the symbolic constants defined earlier to setup the built-in LED and the pin that will control the servo. We also make the servo to rotate to the \texttt{servoMin} angle on launch (line \ref{code:arduino-part2:servoMin}). Our servo will only rotate between \texttt{servoMin} and \texttt{servoMax} degree. We then set the baud rate for the serial communication to the default value of Arduino's, which is 9600. The last step is to seed the built-in PRNG from which we will use to generate random integer value in later part of the implementation.

Listing \ref{code:arduino-part3} shows an (over) simplified implementation version of the \texttt{loop()} function.
\begin{lstlisting}[language=C++, caption= Arduino Program (part 3), escapeinside={(*}{*)}, label=code:arduino-part3]
void loop() {
     if (Serial.available() > 0) {
        // read from serial and process the received message
     }
     if (millis() - myTime > publishDelay) {
        // send random temperature and humidity value to Serial
     }
}
\end{lstlisting}
There are 2 events happens inside the forever loop. The first event occurs whenever the \texttt{Serial} instance detects incoming serial data coming from the Gateway. If this is the case, we will start process the character sequence to decode the message. The routine to accomplish this is explained in sub-section \ref{decoding-message}. The second event of the big loop occurs every a fixed amount of time, determined by the \texttt{publishDelay} variable. Currently, as shown in the listing, we are sending data packets to the Serial every 20 seconds. The \texttt{millis()} function is a built-in function that returns the number of milliseconds passed since the Arduino board began running the current program. To establish the 20s-delay inside the loop without hindering the serial's routine, we will utilise this handy function. We constantly ask for the elapsed time, and whenever the period surpassed the value stored in the \texttt{publishDelay} variable, we do the transmitting-data routine, which will be explained in subsection \ref{transmitting-data}.
\clearpage

\subsection{Decoding-Message Routine}
\label{decoding-message}
Listing \ref{code:arduino-part4} shows what happens if a character sequence is detected at the serial.
\begin{lstlisting}[language=C++, caption= Arduino Program (part 4), escapeinside={(*}{*)}, label=code:arduino-part4]
if (Serial.available() > 0) {
    // expected data pactket of the form: !<TOPIC_ENUM>:<VALUE>#
    Serial.readBytesUntil('#', buff, BUFFER_SIZE);
    String payload = String(buff);
    if (payload.length() > 0) {
      int code = payload.substring(payload.indexOf('!') + 1, payload.indexOf(':')).toInt();
      int value = payload.substring(payload.indexOf(':') + 1, payload.indexOf('#')).toInt();
      switch(code) {
      case 0:
        digitalWrite(LED_BUILTIN, (value == 1) ? HIGH : LOW);
        break;
      case 1:
        servo.write(constrain(value, servoMin, servoMax));
        break;
      default:
        break;
      } // !switch
    } // !payload > 0
} // !serial.available()
\end{lstlisting}
We use a method called \texttt{readBytesUntil()} to save the incoming character sequence in the \texttt{buff} array. We terminate the reading whenever we hit a \#, as it marked the end of the message sequence. Having read the message as a C-style string, we construct a String instance for it and save the newly constructed object to the \texttt{payload} variable. The use of String here is to simplify further manipulation on the message sequence since the Arduino offer rich methods to handle String than that of raw C-style string.

It may seem redundant, but the first \texttt{if} coming right after the first string processing is to ensure we are not digging in an empty string, since we are about to invoke some expensive methods. We start off extracting the enumerated code that encodes the node that this message is targeting. It should be (for this moment) either the LED or the servo node. We will use 0 for LED and 1 otherwise. The next step is to extract the the data value that the Gateway wishes to enact on the target node and save it to the \texttt{value} variable. When done, we can happily use a simple \texttt{switch} statement on the \texttt{code} variable and process on according matches.\\ \\
\clearpage

\subsection{Transmitting-Data Routine}
\label{transmitting-data}
The following listing shows the activities happening every 20s-delay.
\begin{lstlisting}[language=C++, caption= Arduino Program (part 5), escapeinside={(*}{*)}, label=code:arduino-part5]
if (millis() - myTime > publishDelay) {
    myTime = millis();  // reset current time
    // using data frame of the form: !<ID>:<topic_name>:<data>:#
    Serial.print("!1:temperature:" + String(random(0, 100)) + "#");
    Serial.print("!1:humidity:" + String(random(0, 100)) + "#");
}
\end{lstlisting}
The code is straightforward. Whenever we hit the 20s interval, we reset the \texttt{myTime} variable to the current amount of elapsed time, and then start sending 2 random value (invoked through the \texttt{random()} function) for temperature and humidity.

Now that we've done with the first layer of our IoT system. The full implementation of this module can be found under the folder named \textit{arduino-node} inside this Github \href{https://github.com/hescul/adafruit-simple-iot}{\textcolor{blue}{repository}}.
\clearpage